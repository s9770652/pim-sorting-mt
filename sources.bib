@article{Shell1959AHS,
	author={Donald Lewis Shell},
	title={A high-speed sorting procedure},
	journaltitle={Communications of the ACM},
	date={1959-07-01},
	editor={Alan J. Perlis},
	volume={2},
	issue={7},
	pages={30-32},
	doi={10.1145/368370.368387},
}

@misc{skean2023optimization,
	author={Oscar Skean and Richard Ehrenborg and Jerzy W. Jaromczyk},
	title={Optimization Perspectives on Shellsort},
	date={2023-01-01},
	eprint={2301.00316v1},
	archivePrefix={arXiv},
	primaryClass={cs.DS},
}

@InProceedings{10.1007/3-540-44669-9_12,
	author={Marcin Ciura},
	editor={Freivalds, R{\={u}}si{\c{n}}{\v{s}}},
	title={Best Increments for the Average Case of Shellsort},
	booktitle={Fundamentals of Computation Theory},
	date={2001-08-02},
	publisher={Springer Berlin Heidelberg},
	address={Berlin, Heidelberg},
	pages={106-117},
	abstract={This paper presents the results of using sequential analysis to find increment sequences that minimize the average running time of Shellsort, for array sizes up to several thousand elements. The obtained sequences outperform by about 3{\%} the best ones known so far, and there is a plausible evidence that they are the optimal ones."},
	isbn={978-3-540-44669-9},
	doi={10.1007/3-540-44669-9_12},
%	url={https://web.archive.org/web/20180923235211/http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf},
%	urldate={2024-05-24},
}

@misc{lee2021empirically,
	author={Ying Wai Lee},
	title={Empirically Improved Tokuda Gap Sequence in Shellsort},
	date={2021-12-21},
	eprint={2112.11112v1},
	archivePrefix={arXiv},
	primaryClass={cs.DS},
}

@report{lukas_geis,
	author={Lukas Geis},
	title={Random Number Generation in the Pim-Architecture},
	type={Research Project Report},
	institution={Goethe University Frankfurt},
	date={2024},
	version={8c11f1f},
	pagetotal={13},
	url={https://github.com/lukasgeis/upmem-rng/blob/main/report/report.pdf},
	urldate={2024-05-19},
}

@misc{axtmann2020engineering,
	author={Michael Axtmann and Sascha Witt and Daniel Ferizovic and Peter Sanders},
	title={Engineering In-place (Shared-memory) Sorting Algorithms},
	date={2021-02-03},
	eprint={2009.13569v2},
	archivePrefix={arXiv},
	primaryClass={cs.DC},
}

@article{wegener1993heapsort,
	author={Ingo Wegener},
	title={BOTTOM-UP-HEAPSORT, a new variant of HEAPSORT beating, on an average, QUICKSORT (if \(n\) is not very small)},
	journal={Theoretical Computer Science},
	volume={118},
	issue={1},
	pages={81-98},
	date={1993-09-13},
	issn={0304-3975},
	doi={10.1016/0304-3975(93)90364-Y},
%	doi={https://doi.org/10.1016/0304-3975(93)90364-Y},
%	url={https://www.sciencedirect.com/science/article/pii/030439759390364Y},
	abstract={A variant of HEAPSORT, called BOTTOM-UP-HEAPSORT, is presented. It is based on a new reheap procedure. This sequential sorting algorithm is easy to implement and beats, on an average, QUICKSORT if n⩾400 and a clever version of QUICKSORT (where the split object is the median of 3 randomly chosen objects) if n⩾16000. The worst-case number of comparisons is bounded by 1.5n log n+O(n). Moreover, the new reheap procedure improves the delete procedure for the heap data structure for all n.},
}

@article{hoare1962quicksort,
	author={Charles Antony Richard Hoare},
	title={Quicksort},
	journal={The Computer Journal},
	volume={5},
	number={1},
	pages={10-16},
	year={1962},
	month={01},
	abstract="{A description is given of a new method of sorting in the random-access store of a computer. The method compares very favourably with other known methods in speed, in economy of storage, and in ease of programming. Certain refinements of the method, which may be useful in the optimization of inner loops, are described in the second part of the paper.}",
	issn={0010-4620},
	doi={10.1093/comjnl/5.1.10},
%	url={https://doi.org/10.1093/comjnl/5.1.10},
%	eprint={https://academic.oup.com/comjnl/article-pdf/5/1/10/1111445/050010.pdf},
}

@article{erkiö1984worstcase,
	author={Hannu Erkiö},
	title={The Worst Case Permutation for Median-of-Three Quicksort},
	journal={The Computer Journal},
	volume={27},
	number={3},
	pages={276-277},
	year={1984},
	month={01},
	abstract="{An algorithm is given which forms the worst case permutation for one of the most efficient versions of quicksort (median-of-three quicksort). This makes the experimental evaluation of this important algorithm possible. The paper includes a simple experimental comparison of the median-of-three and original versions of quicksort.}",
	issn={0010-4620},
	doi={10.1093/comjnl/27.3.276},
%	url={https://doi.org/10.1093/comjnl/27.3.276},
%	eprint={https://academic.oup.com/comjnl/article-pdf/27/3/276/1049274/270276.pdf},
}

@online{blum2011probabilistic,
	author={Avrim Blum and Manuel Blum},
	title={Lecture 3},
	subtitle={Probabilistic Analysis and Randomized Quicksort},
	date={2011-09-06},
	url={https://www.cs.cmu.edu/~avrim/451f11/lectures/lect0906.pdf},
	organization={Carnegie Mellon University},
	urldate={2024-07-26},
}

@article{blum1973median,
	author={Manuel Blum and Robert W. Floyd and Vaughan Pratt and Ronald L. Rivest and Robert E. Tarjan},
	title={Time bounds for selection},
	journal={Journal of Computer and System Sciences},
	volume={7},
	number={4},
	pages={448-461},
	date={1973-08},
	editor={Arnold Leonard Rosenberg},
	issn={0022-0000},
	doi={https://doi.org/10.1016/S0022-0000(73)80033-9},
%	url={https://www.sciencedirect.com/science/article/pii/S0022000073800339},
	abstract={The number of comparisons required to select the i-th smallest of n numbers is shown to be at most a linear function of n by analysis of a new selection algorithm—PICK. Specifically, no more than 5.4305 n comparisons are ever required. This bound is improved for extreme values of i, and a new lower bound on the requisite number of comparisons is also proved.},
}

@InProceedings{katajainen1997meticulous,
	author={Jyrki Katajainen and Jesper Larsson Tr{\"a}ff},
	editor={Giancarlo Bongiovanni and Daniel Pierre Bovet and Giuseppe Di Battista},
	title={A meticulous analysis of mergesort programs},
	booktitle={Algorithms and Complexity},
	date={1997-03-12},
	publisher={Springer Berlin Heidelberg},
	address={Berlin, Heidelberg},
	pages={217-228},
	abstract={The efficiency of mergesort programs is analysed under a simple unit-cost model. In our analysis the time performance of the sorting programs includes the costs of key comparisons, element moves and address calculations. The goal is to establish the best possible time-bound relative to the model when sorting n integers. By the well-known information-theoretic argument n log2n−O(n) is a lower bound for the integer-sorting problem in our framework. New implementations for two-way and four-way bottom-up mergesort are given, the worst-case complexities of which are shown to be bounded by 5.5n log2n+O(n) and 3.25n log2n+O(n), respectively. The theoretical findings are backed up with a series of experiments which show the practical relevance of our analysis when implementing library routines for internal-memory computations.},
	isbn={978-3-540-68323-0},
	doi={10.1007/3-540-62592-5_74},
}

@manual{upmemSDK,
	title={UPMEM DPU SDK Documentation},
	date={2024},
	version={2024.1.0},
	organization={UPMEM},
	location={Grenoble},
	url={https://sdk.upmem.com/2024.1.0},
}

@article{williams1964heapsort,
	author={John William Joseph Williams},
	title={Algorithm 232},
	subtitle={Heapsort},
	journaltitle={Communications of the ACM},
	date={1964-06-01},
	editor={George Elmer Forsythe},
	volume={7},
	issue={6},
	pages={347-348},
	doi={10.1145/512274.512284},
}

@article{floyd1964treesort,
	author={Robert W Floyd},
	title={Algorithm 245},
	subtitle={Treesort 3},
	journaltitle={Communications of the ACM},
	date={1964-12-01},
	editor={Calvin Carl Gotlieb},
	volume={7},
	issue={12},
	pages={701},
	doi={10.1145/355588.365103},
}

@article{codish2017sortingnetworks,
	author={Michael Codish and Luis Cruz-Filipe and Markus Nebel and Peter Shcneider-Kamp},
	title={Optimizing Sorting Algorithms by Using Sorting Networks},
	journaltitle={Formal Aspects of Computing},
	date={2017-05-01},
	editor={Moreno Falaschi and Augusto Sampaio},
	volume={29},
	issue={3},
	pages={559-579},
	abstract={In this paper, we show how the theory of sorting networks can be applied to synthesize optimized general-purpose sorting libraries. Standard sorting libraries are often based on combinations of the classic Quicksort algorithm, with insertion sort applied as base case for small, fixed, numbers of inputs. Unrolling the code for the base case by ignoring loop conditions eliminates branching, resulting in code equivalent to a sorting network. By replacing it with faster sorting networks, we can improve the performance of these algorithms. We show that by considering the number of comparisons and swaps alone we are not able to predict any real advantage of this approach. However, significant speed-ups are obtained when taking advantage of instruction level parallelism and non-branching conditional assignment instructions, both of which are common in modern CPU architectures. Furthermore, a close control of how often registers have to be spilled to memory gives us a complete explanation of the performance of different sorting networks, allowing us to choose an optimal one for each particular architecture. Our experimental results show that using code synthesized from these efficient sorting networks as the base case for Quicksort libraries results in significant real-world speed-ups.},
	doi={10.1007/s00165-016-0401-3},
}

@online{m2015fastestway,
	author={{m69 ''snarky and unwelcoming'' [sic!].}},
	title={Fastest way to sort 10 numbers? (numbers are 32 bit)},
	date={2015-08-24},
	url={https://stackoverflow.com/a/32173153},
	organization={Stack Overflow},
	urldate={2024-08-11},
}

@online{paulr2010fastestsort,
	author={Paul R},
	title={Fastest sort of fixed length 6 int array},
	date={2010-05-07},
	url={https://stackoverflow.com/a/2786959},
	organization={Stack Overflow},
	urldate={2024-08-11},
}

@misc{peters2021patterndefeatingquicksort,
	title={Pattern-defeating Quicksort},
	author={Orson Raphael Lennard Peters},
	date={2021-06-09},
	eprint={2106.05123},
	archivePrefix={arXiv},
	primaryClass={cs.DS},
	url={https://arxiv.org/abs/2106.05123},
}

@InProceedings{wild2012averagecase,
	author={Sebastian Wild and Markus E. Nebel},
	editor={Leah Epstein and Paolo Ferragina},
	title={Average Case Analysis of Java 7's Dual Pivot Quicksort},
	booktitle={Algorithms -- ESA 2012},
	date={2012-09-10},
	publisher={Springer Berlin Heidelberg},
	address={Berlin, Heidelberg},
	pages={825-836},
	abstract={Recently, a new Quicksort variant due to Yaroslavskiy was chosen as standard sorting method for Oracle's Java 7 runtime library. The decision for the change was based on empirical studies showing that on average, the new algorithm is faster than the formerly used classic Quicksort. Surprisingly, the improvement was achieved by using a dual pivot approach, an idea that was considered not promising by several theoretical studies in the past. In this paper, we identify the reason for this unexpected success. Moreover, we present the first precise average case analysis of the new algorithm showing e.g. that a random permutation of length n is sorted using {\$}1.9n{\backslash}ln n-2.46n+{\backslash}mathcal{\{}O{\}}({\backslash}ln n){\$}key comparisons and {\$}0.6n{\backslash}ln n+0.08n+{\backslash}mathcal{\{}O{\}}({\backslash}ln n){\$}swaps.},
	isbn={978-3-642-33090-2},
	doi={10.1007/978-3-642-33090-2_71},
}

@book{lang2009algorithmen,
	author={Hans Werner Lang},
	title={Algorithmen in Java},
	date={2009-12-16},
	editor={Margit Roth},
	language={German},
	edition={2},
	publisher={Oldenbourg Wissenschaftsverlag},
	location={München},
	isbn={978-3-486-59340-2},
	pagetotal={384},
	doi={10.1524/9783486593402},
}

@misc{penschuck2024personal,
	author={Manuel Penschuck},
	title={Personal communication},
	date={2024},
	organization={Goethe University},
	location={Frankfurt},
}

@article{mutlu2022Benchmarking,
	author={Juan Gómez-Luna and Izzat El Hajj and Ivan Fernandez and Christina Giannoula and Geraldo Francisco de Oliveira and Onur Mutlu},
	journal={IEEE Access},
	title={Benchmarking a New Paradigm: Experimental Analysis and Characterization of a Real Processing-in-Memory System},
	date={2022-05-10},
	volume={10},
	pages={52565-52608},
	abstract={Many modern workloads, such as neural networks, databases, and graph processing, are fundamentally memory-bound. For such workloads, the data movement between main memory and CPU cores imposes a significant overhead in terms of both latency and energy. A major reason is that this communication happens through a narrow bus with high latency and limited bandwidth, and the low data reuse in memory-bound workloads is insufficient to amortize the cost of main memory access. Fundamentally addressing this data movement bottleneck requires a paradigm where the memory system assumes an active role in computing by integrating processing capabilities. This paradigm is known as processing-in-memory (PIM). Recent research explores different forms of PIM architectures, motivated by the emergence of new 3D-stacked memory technologies that integrate memory with a logic layer where processing elements can be easily placed. Past works evaluate these architectures in simulation or, at best, with simplified hardware prototypes. In contrast, the UPMEM company has designed and manufactured the first publicly-available real-world PIM architecture. The UPMEM PIM architecture combines traditional DRAM memory arrays with general-purpose in- order cores, called DRAM Processing Units (DPUs), integrated in the same chip. This paper provides the first comprehensive analysis of the first publicly-available real-world PIM architecture. We make two key contributions. First, we conduct an experimental characterization of the UPMEM-based PIM system using microbenchmarks to assess various architecture limits such as compute throughput and memory bandwidth, yielding new insights. Second, we present PrIM (Processing-In-Memory benchmarks), a benchmark suite of 16 workloads from different application domains (e.g., dense/sparse linear algebra, databases, data analytics, graph processing, neural networks, bioinformatics, image processing), which we identify as memory-bound. We evaluate the performance and scaling characteristics of PrIM benchmarks on the UPMEM PIM architecture, and compare their performance and energy consumption to their modern CPU and GPU counterparts. Our extensive evaluation conducted on two real UPMEM-based PIM systems with 640 and 2,556 DPUs provides new insights about suitability of different workloads to the PIM system, programming recommendations for software designers, and suggestions and hints for hardware and architecture designers of future PIM systems.},
	keywords={Computer architecture;Benchmark testing;Random access memory;Graphics processing units;Hardware;Software;Energy consumption;Processing-in-memory;near-data processing;memory systems;data movement bottleneck;DRAM;benchmarking;real-system characterization;workload characterization},
	doi={10.1109/ACCESS.2022.3174101},
	ISSN={2169-3536},
}

@book{cormen2013algorithmen,
	author = {Thomas H. Cormen and Charles Eric Leiserson and Ronald Linn Rivest and Clifford Seth Stein},
	title = {Algorithmen},
	date = {2013-10-17},
	translator = {Paul Molitor},
	subtitle = {Eine Einführung},
	language = {German},
	origlanguage = {English},
	edition = {4},
	publisher = {Oldenbourg Wissenschaftsverlag},
	location = {Munich},
	isbn = {978-3-486-74861-1},
	pagetotal = {1319},
}

@book{maurer1974datenstrukturen,
	author={Hermann Maurer and Hans-Werner Six},
	title={Datenstrukturen und Programmierverfahren},
	date={1974},
	editor={Heinrich Görtler},
	language={German},
	series={Leitfäden der angewandten Mathematik und Mechanik},
	number={25},
	note={Teubner Studienbücher Informatik},
	publisher={B. G. Teubner},
	location={Stuttgart},
	isbn={3-519-02328-8},
	pagetotal={222},
}

@book{wirth1975algorithmen,
	author={Niklaus Wirth},
	title={Algorithmen und Datenstrukturen},
	date={1975},
	editor={Heinrich Görtler},
	language={German},
	series={Leitfäden der angewandten Mathematik und Mechanik},
	number={32},
	note={Teubner Studienbücher Informatik},
	publisher={B. G. Teubner},
	location={Stuttgart},
	isbn={3-519-02330-X},
	pagetotal={376},
}
