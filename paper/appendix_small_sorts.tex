\subsection{\texorpdfstring{\QS{}}{QuickSort}}
\label{subsec:appendix:quick}

\pgfplotstableread{data/quick/fallback.txt}{\tablequickfallback}
\pgfplotstableread{data/quick/recursive/no switched sides/uniform/end.txt}{\tablequickrecnssuniend}
\pgfplotstableread{data/quick/recursive/no switched sides/uniform/middle.txt}{\tablequickrecnssunimiddle}
\pgfplotstableread{data/quick/recursive/no switched sides/uniform/median_of_three.txt}{\tablequickrecnssunimedian}
\pgfplotstableread{data/quick/recursive/no switched sides/uniform/random.txt}{\tablequickrecnssunirandom}
\pgfplotstableread{data/quick/recursive/switched sides/uniform/end.txt}{\tablequickrecssuniend}
\pgfplotstableread{data/quick/recursive/switched sides/uniform/middle.txt}{\tablequickrecssunimiddle}
\pgfplotstableread{data/quick/recursive/switched sides/uniform/median_of_three.txt}{\tablequickrecssunimedian}
\pgfplotstableread{data/quick/recursive/switched sides/uniform/random.txt}{\tablequickrecssunirandom}
\pgfplotstableread{data/quick/iterative/no switched sides/uniform/end.txt}{\tablequickitnssuniend}
\pgfplotstableread{data/quick/iterative/no switched sides/uniform/middle.txt}{\tablequickitnssunimiddle}
\pgfplotstableread{data/quick/iterative/no switched sides/uniform/median_of_three.txt}{\tablequickitnssunimedian}
\pgfplotstableread{data/quick/iterative/no switched sides/uniform/random.txt}{\tablequickitnssunirandom}
\pgfplotstableread{data/quick/iterative/switched sides/uniform/end.txt}{\tablequickitssuniend}
\pgfplotstableread{data/quick/iterative/switched sides/uniform/middle.txt}{\tablequickitssunimiddle}
\pgfplotstableread{data/quick/iterative/switched sides/uniform/median_of_three.txt}{\tablequickitssunimedian}
\pgfplotstableread{data/quick/iterative/switched sides/uniform/random.txt}{\tablequickitssunirandom}

\begin{figure}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			width=0.4358\linewidth,
			group/group size=2 by 1,
			group style={horizontal sep=5em, vertical sep=3em},  % For some reason, `group/vertical sep` does not work.
			groupplot xlabel={Input Length \(n\)},
			groupplot ylabel={Speed-up},
			xmode=log,
			xtick={20, 32, 64, 128, 256, 512, 1024},
			xticklabels={\(20\), \(32\), \(64\), \(128\), \(256\), \(512\), \(1024\)},
%			minor xtick={24, 48, 96, 192, 384, 768, 1536},  % For some reason, `data` does not work.
			legend columns=-1,
		]
			\nextgroupplot[title={Over No Fallback\strut}, legend to name=leg:quick_fallback]
			\legend{\(10\), \(11\), \(...\), \(16\)}
			\pgfplotsinvokeforeach{10,...,16}{
				\plotspeedup{#1}{None}{\tablequickfallback}
			}
			%
			\nextgroupplot[title={Over a Threshold of 13\strut}, /pgf/number format/.cd, precision=3, fixed zerofill=true]
			\pgfplotsinvokeforeach{10,...,16}{
				\ifnumequal{#1}{13}{
					\pgfplotsset{cycle list shift=1}
				}{
					\plotspeedup{#1}{13}{\tablequickfallback}
				}
			}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:quick_fallback}\hfil
	\caption{
		Comparison of \QS*{} with different thresholds for the fallback to \IS{}, with a \QS{} without fallback algorithm and the fastest \QS{} with a threshold of 13 elements.
	}
	\label{fig:quick_fallback}
\end{figure}


Two base cases exist:
\begin{enumerate*}
	\item
	If there are less than two elements left, terminate.

	\item
	If there are less than 14 elements left, call \IS{}.
\end{enumerate*}
The first base case is not strictly necessary as the second one covers it.
The fastest implementation with 622\,750 cycles on average for 1024 elements is as follows:
\begin{enumerate}
	\item\label[implementation]{imp:normal}
	If the partition has a length of 1 or less, terminate.
	If not and if the threshold is undercut, sort with \IS{}.
	Otherwise, sort with \QS{} and call \QS{} on both the left and right partition.
	\textcolor{red}{[Normal]}
\end{enumerate}
The following implementation, which avoids some function calls by reordering the checks, is ever so slightly slower at 625\,150 cycles:
\begin{enumerate}[resume]
	\item\label[implementation]{imp:triviality_before_call}
	If the threshold is undercut, sort with \IS{}.
	Otherwise, sort with \QS{}.
	Then check if the partitions have a length of 1 or less and call \QS{} on them if not.
	\textcolor{red}{[TrivialBC]}
\end{enumerate}
A look at the compilation reveals that only some jumps at the start and at the end of the function have changed.
It appears that the changed program flow causes one additional operation per call, since \QS{} gets called roughly 230 times and 230 × 11 cycles = 2530 cycles, which is the measured difference.
This one operation is already too much as partitions hardly have such short lengths and function calls are cheap.

But what if one were to get rid of all recursive calls on partitions below the threshold?
After all, they come up roughly 350 times.
Or what if one tried any other handling of the base cases?
All of the following implementations take between 710\,000 and 725\,000 cycles:
\begin{enumerate}[resume]
	\item\label[implementation]{imp:one_insertion}
	If the threshold is undercut, terminate.
	Otherwise, sort with \QS{} and call \QS{} on both the left and right partition.
	After all \QS*{} are done, sort the whole input array with \IS{}.
	\textcolor{red}{[OneInsertion]}

	\item\label[implementation]{imp:no_triviality}
	If the threshold is undercut, sort with \IS{}.
	Otherwise, sort with \QS{} and call \QS{} on both the left and right partition.
	\textcolor{red}{[NoTrivial]}

	\item\label[implementation]{imp:threshold_then_triviality}
	If the threshold is undercut, sort with \IS{}.
	If not, terminate if the partition has a length of 1 or less.
	Otherwise, sort with \QS{} and call \QS{} on both the left and right partition.
	\textcolor{red}{[ThreshThenTriv]}

	\item\label[implementation]{imp:threshold_before_call}
	Sort with \QS{}.
	Check if the partitions undercut the threshold and either call \IS{} or \QS{} on them.
	\textcolor{red}{[ThreshBC]}

	\item\label[implementation]{imp:threshold_and_triviality_before_call}
	Sort with \QS{}.
	Check if the partitions have a length of 1 or less or at least undercut the threshold and either call \IS{}, \QS{} or nothing on them.
	\textcolor{red}{[ThreshTrivBC]}

	\item\label[implementation]{imp:triviality_within_threshold}
	If the threshold is undercut, check whether the partition has a length of 1 or less and either terminate or sort with \IS{}.
	Otherwise, sort with \QS{} and call \QS{} on both the left and right partition.
	\textcolor{red}{[TrivInThresh]}
\end{enumerate}
In each of them, the compiler makes poorer use of the registers with the biggest impact on the loop which finds the next element to move to the right, increasing the length of an iteration from three instructions to four.

The phenomenon gets more complicated when one considers the iterative implementation.
In that case, \cref{imp:triviality_within_threshold} is the fastest with \cref{imp:triviality_before_call} coming in close second and all other implementations deteriorating to the similarly bad runtimes.

\todo[inline]{Verweis auf Begründung in Rek.\ gg.\ Iter.?}
\todo[inline]{Extra-Code ist teilweise verbuggt!}

\begin{figure}[p]
	\def\algos{Normal,TrivialBC,NoTrivial,OneInsertion,ThreshBC,ThreshTrivBC,ThreshThenTriv,TrivInThresh}
	\pgfplotsset{
		width=0.2308\linewidth,
		height=3.5cm,
		group/group size=4 by 2,
		group style={horizontal sep=1em, vertical sep=3.5em},  % For some reason, `group/horizontal sep` does not work.
		groupplot xlabel={Input Length \(n\)},
		groupplot ylabel={Cycles / \((n \lb n)\)},
		xmode=log,
		xtick={20, 64, 256, 1024},
		xticklabels={\(20\), \(64\), \(256\), \(1024\)},
		minor xtick={32, 128, 512},
		ymin=55,
		ymax=79,
		ytick={55,59,...,79},
		legend columns=-1,
	}
	\begin{subfigure}{\textwidth}
		\begin{tikzpicture}[plot]
			\begin{groupplot}
				\nextgroupplot[title={Last | Left First}, legend to name=leg:quick_implementations]
				\legend{\ref{imp:normal}, \ref{imp:triviality_before_call}, \ref{imp:no_triviality}, \ref{imp:one_insertion}, \ref{imp:threshold_before_call}, \ref{imp:threshold_and_triviality_before_call}, \ref{imp:threshold_then_triviality}, \ref{imp:triviality_within_threshold}}
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecnssuniend}
				}
				%
				\nextgroupplot[title={Middle | Left First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecnssunimiddle}
				}
				%
				\nextgroupplot[title={Median | Left First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecnssunimedian}
				}
				%
				\nextgroupplot[title={Random | Left First}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecnssunirandom}
				}
				%
				\nextgroupplot[title={Last | Right First}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecssuniend}
				}
				%
				\nextgroupplot[title={Middle | Right First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecssunimiddle}
				}
				%
				\nextgroupplot[title={Median | Right First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecssunimedian}
				}
				%
				\nextgroupplot[title={Random | Right First}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickrecssunirandom}
				}
			\end{groupplot}
		\end{tikzpicture}
		\caption{
			Recursive Implementation
		}
		\bigskip
	\end{subfigure}
	%
	\begin{subfigure}{\textwidth}
		\begin{tikzpicture}[plot]
			\begin{groupplot}
				\nextgroupplot[title={Last | Left First}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitnssuniend}
				}
				%
				\nextgroupplot[title={Middle | Left First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitnssunimiddle}
				}
				%
				\nextgroupplot[title={Median | Left First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitnssunimedian}
				}
				%
				\nextgroupplot[title={Random | Left First}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitnssunirandom}
				}
				%
				\nextgroupplot[title={Last | Right First}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitssuniend}
				}
				%
				\nextgroupplot[title={Middle | Right First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitssunimiddle}
				}
				%
				\nextgroupplot[title={Median | Right First}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitssunimedian}
				}
				%
				\nextgroupplot[title={Random | Right First}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\algos}{
					\plotpernlogn{#1}{\tablequickitssunirandom}
				}
			\end{groupplot}
		\end{tikzpicture}
		\caption{
			Iterative Implementation
		}
	\end{subfigure}

	\bigskip
	\hfil\pgfplotslegendfromname{leg:quick_implementations}\hfil
	\caption{
		Comparison of the different implementations (1--8) of \QS{} for all possible pivot choices.
		In the first rows, the left partitions are sorted before the right ones, while it is the reverse in the second rows.
	}
	\label{fig:quick_implementations}
\end{figure}
