\subsection{\texorpdfstring{\HS{}}{HeapSort}}
\label{subsec:tasklet:heap}

\pgfplotsinvokeforeach{sorted,reverse,almost,uniform,zipf,normal}{
	\pgfplotstablereadnamed{data/heap/uint32/#1.txt}{tableHeap_32#1}
	\pgfplotstablereadnamed{data/heap/uint64/#1.txt}{tableHeap_64#1}
}

\paragraph{Implementation Variants}
After the root has been extracted, the \emph{mono-directional} \HS{} proceeds as follows:
The rightmost leaf in the bottom layer is moved

\paragraph{Indexing}
With a zero-based indexing, the sons of a vertex \(i\) can be calculated with the well-known formulas \(2i + 1\) and \(2n + 2\).
With a one-based indexing, the formulas turn into \(2i\) and \(2i + 1\).
The compiler automatically turns the multiplication by two into a left-shift by one.
Since DPUs can execute an instruction called \lstinline|lsl_add| which first shifts leftwards and then adds an offset (useful \eg{} for array indexing), the formulas \(2i + 1\) and \(2i\) take the same amount of time to compute.

Nevertheless, the zero-based indexing is about 7\% slower despite \lstinline|lsl_add| being indeed in use.
The reason is that only the number of bits to shift can be passed as immediate value, that is as plain number, but not the offset, which must be passed via a register.
While DPUs have a read-only register storing the number \(1\) at disposal, read-only registers can only ever be the first register argument, not the second one, which, for \lstinline|lsl_add|, would be the offset.
As a consequence, the compiler moves the number \(1\) to a register whenever \(2i + 1\) is to be computed, only to immediately overwrite the \(1\) with the result from \lstinline|lsl_add|.
Hence, the calculation of \(2i + 1\) does take one more instruction than \(2n\) after all.

\paragraph{Sentinel Values}
Whenever \HS{} moves downwards in the heap and considers a vertex and its two sons, it needs to determine the bigger of the two before deciding whether to proceed.
If and only if the heap has an even number of vertices, there is a left son without a right brother:
the rightmost leaf in the bottom layer.
Instead of adding some check on whether the right brother exists, one can rather add the missing leaf and set it to the smallest possible value each time the heap reaches an even size.
Thus, if it has been confirmed that a left son exists, a right one does also exist, and if two brothers are set to the same value, the left one should be considered bigger.

Likewise, whenever \HS{} moves upwards in the heap and considers the father \(\sfrac{i}{2}\) of a vertex \(i\), it will only proceed if the father is smaller.
Since the fatherless root has index \(1\) and the result of an integer division is truncated towards \(0\) in C, the formula yields \(0\), so it makes sense to set the element at index \(0\) to the highest possible value to stop any upwards motion.
The savings from these approaches were around the 13\% mark.

\paragraph{Code Duplication}
A strategy of particular use in \HS{}, although also employed in \MS{}, is code duplication:
Handling the bigger of two sons is the fastest if the logic is written twice, once for either son, and then executed conditionally;
logic written once for a general variable holding the bigger son is compiled considerably worse.
The savings from this approach were around the 7\% mark.

\begin{itemize}
	\item
	if n even: vor T\_MIN: -5000 -- +15000 Takte

	\item
	Var 1:
	leichter trend nach oben

	Var 2:
	leichter downwards trend

	Effekte stärker für 64 Bit

	\item
	32 Bit: bis 6250

	64 Bit: bis 6250
\end{itemize}

\pgfplotsset{
	heap/.style={
		adaptive group=1 by 2,
		groupplot xlabel={Input Length \(n\)},
		groupplot ylabel={Cycles / \(n \lb n\)},
		xmode=log,
		xtick={16, 32, 64, 128, 256, 512, 1024},
		xticklabels={\(16\), \(32\), \(64\), \(128\), \(256\), \(512\), \(1024\)},
		legend columns=-1,
	},
}
\def\heapalgos{HeapOnlyDown,HeapUpDown}

\begin{figure}
	\tikzsetnextfilename{heap_runtime}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[heap]
			\nextgroupplot[title={32-bit\strut}, ymin=130, ymax=145, legend to name=leg:heap:runtime]
			\legend{\HS{}, \HS{}}
			\expandafter\pgfplotsinvokeforeach\expandafter{\heapalgos}{
				\plotpernlogn{#1}{tableHeap_32uniform}
			}
			%
			\nextgroupplot[title={64-bit\strut}, ymin=155, ymax=175]
			\expandafter\pgfplotsinvokeforeach\expandafter{\heapalgos}{
				\plotpernlogn{#1}{tableHeap_64uniform}
			}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:heap:runtime}\hfil
	\caption{
		Comparison of the runtimes of the two different \HS{} implementations on uniformly distributed 32-bit integers and 64-bit integers, respectively.
	}
	\label{fig:heap:runtime}
\end{figure}
