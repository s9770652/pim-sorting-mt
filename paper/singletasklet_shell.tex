\subsection{\ShS{}}

\begin{figure}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			width=0.4358\linewidth,
			group/group size=2 by 1,
			groupplot xlabel={Input Length \(n\)},
			xtick distance=3,
			minor xtick=data,
			legend columns=-1,
		]
			\nextgroupplot[ylabel=Cycles / \(n^2\), ymin=0, ymax=80, legend to name=leg:shell_sort]
			\legend{\(1\), \(...\), \(9\)}
			\pgfplotsinvokeforeach{1,...,9}{
				\plotpernn{#1}{\tablesmallsorts}
			}
			%
			\nextgroupplot[ylabel=Speed-up, ymin=0.6, ymax=1.2]
			\pgfplotsset{cycle list shift=1}
			\pgfplotsinvokeforeach{2,...,9}{
				\plotspeedup{#1}{1}{\tablesmallsorts}
			}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:shell_sort}\hfil
	\caption{
		Comparison of \IS{} (1) and various \ShS*{} (2--9) on a uniform input distribution.
		Each \ShS{} does one \IS{} pass with a step size between 2 and 9 before doing a pass of regular \IS{}.
		The speed-ups are with respect to the \IS{}.
	}
	\label{fig:shell_sort}
\end{figure}

\IS{} suffers from small elements at the end of the input array, since those have to be brought to the front through \(\bigoh{n}\) comparisons and swaps.
\ShS{}, proposed by Donald L. Shell in 1959 \cite{Shell1959AHS}, remedies this by doing multiple passes of \IS{} with different step sizes:
In round \(i\) with step size \(h_i\), the input array is divided into the subarrays of indices \((0, h_i, 2 h_i, \dots)\), \((1, h_i + 1, 2 h_i +1, \dots)\), \((2, h_i + 2, 2 h_i + 2, \dots)\) and so on which then get sorted individually via \IS{}.
The step size decreases with each round, with the final step size being \(1\) such that a regular \IS{} is performed.
The individual \IS*{} should be fast since elements which need to travel long distances already did big jumps.

Finding the right balance between the heightened overhead through multiple \IS{} passes and the shortened runtime of each \IS{} pass is subject to research\todo{Belege} and depends on the cost of the operations (comparing, swapping, looping)\todo{Unikosten f√ºr DPU analysierend einbauen?}.
Let us first take a quick look on \ShS{} for small input arrays where surely only two rounds with step sizes \(h_1\) and \(1\) suffice.
The previous results on \IS{} suggest that \ShS{} should make use of \(h_1\) sentinel values.
\Cref{fig:shell_sort} shows that the additional rounds starts to pay off at 19 elements for \(h_1 \ge 5\), at 20 elements for \(h_1 \ge 3\), and at 25 elements for \(h_1 = 2\).
Bear in mind that these measurements were conducted on a uniform input distribution;
if \ShS{} is used by another algorithm on a subarray, these thresholds may be even higher or even non-existent due to some degree of presorting.
