\subsection{\IS{}}

\pgfplotstableread{data/small_sorts.txt}{\tablesmallsorts}

\begin{figure}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			width=0.4358\linewidth,
			group/group size=2 by 1,
			groupplot xlabel={Input Length \(n\)},
			xtick distance=3,
			minor xtick=data,
			legend columns=-1,
		]
			\nextgroupplot[ylabel=Cycles / \(n^2\), ymin=0, ymax=70, extra y ticks={70}, legend to name=leg:insertion_sort]
			\legend{Insertion, Insertion (no sentinel), Bubble, Bubble(adaptive), Selection}
			\plotpernn{1}{\tablesmallsorts}
			\plotpernn{1NoSentinel}{\tablesmallsorts}
			\plotpernn{BubbleNonAdapt}{\tablesmallsorts}
			\plotpernn{BubbleAdapt}{\tablesmallsorts}
			\plotpernn{Selection}{\tablesmallsorts}
			%
			\nextgroupplot[ylabel=Speed-up, ymin=0.2, ymax=1]
			\pgfplotsset{cycle list shift=1}
			\plotspeedup{1NoSentinel}{1}{\tablesmallsorts}
			\plotspeedup{BubbleNonAdapt}{1}{\tablesmallsorts}
			\plotspeedup{BubbleAdapt}{1}{\tablesmallsorts}
			\plotspeedup{Selection}{1}{\tablesmallsorts}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:insertion_sort}\hfil
	\caption{
		Comparison of sorting algorithms with \(\bigoh{n^2}\) runtime.
		The \IS*{} differ in whether they rely on sentinel values.
		The adaptive \BS{} terminates prematurely if no changes were made to the input array during an iteration.
		The speed-ups are with respect to the \IS{} relying on sentinel values.
	}
	\label{fig:insertion_sort}
\end{figure}

This stable sorting algorithm works by moving the \(i\)th element to the left as long as its left neighbour is bigger, assuming that the elements \(0\) to \(i - 1\) are already sorted.
Even though in both the average case and the worst case, \IS{} has a runtime of \(\bigoh{n^2}\)\todo{Beleg?}, it features quite some advantages:
\begin{enumerate*}
	\item
	It works in-place, needing only \(\bigoh{1}\) additional space.

	\item
	It is inherently adaptive:
	If the input array is mostly or even fully sorted, the runtime drops down to \(\bigoh{n}\).

	\item
	Its program code is short, lending itself to inlining.

	\item
	The overhead is small.
\end{enumerate*}
Especially the last two points make \IS{} a good base algorithm for asymptotically better sorting algorithms to use on very small subarrays.

When moving an element to the left, two checks are needed:
Does the left neighbour exist and is it smaller than the element to move?
The first check can be omitted through the use of \emph{sentinel values}:
If the element at index \(-1\) is at least as small as any value in the input array, the leftwards motion stops there at the latest.
Since a DPU has no branch predictor, the slowdown from performing twice as many checks as needed is quite high and lies between 20\% and 40\%\todo{auf Kompilat eingehen?} in the relevant input range (\cref{fig:insertion_sort}).%
\todo{ex- und implizite WÃ¤chterwerte benennen}
Thence, \enquote{\IS{}} refers to the version relying on sentinel values henceforth.
\todo[inline]{auf Compilersperenzchen eingehen?}

\begin{note}
	Other known simple sorting algorithm with similar runtime complexity are \SelS{} and \BS{}.
	The asymptoticity, however, hides much higher constant factors such that even for as little as three elements \IS{} is superior (\cref{fig:insertion_sort}) and should always be preferred.
\end{note}
