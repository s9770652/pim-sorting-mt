\subsection{\texorpdfstring{\IS{}}{InsertionSort}}
\label{subsec:single:insertion}

\pgfplotstableread{data/small sorts/uint32/uniform.txt}{\tableSmallSortsXxxiiUniform}

This stable sorting algorithm works by moving the \(i\)th element leftwards as long as its left neighbour is bigger, assuming that the elements at the indices \(0\) to \(i - 1\) are already sorted.
Its asymptotic runtime is bad, reaching \(\bigoh*{n^2}\) not only in the worst case but also in the average case, where each of the \(\binom{n}{2}\) pairs of input elements is in wrong order and will be swapped at some point in the execution with probability 50\%.
Nonetheless, \IS{} does have some saving graces:
\begin{enumerate*}
	\item
	If the input array is mostly or even fully sorted, the runtime drops down to \(\bigoh{n}\).

	\item
	It works in-place, needing only \(\bigoh{1}\) additional space.

	\item
	Its program code is short, lending itself to inlining.

	\item
	The overhead is small.
\end{enumerate*}
Especially the last two points make \IS{} a good fall-back algorithm for asymptotically better sorting algorithms to use on small subarrays.

When moving an element to the left, two checks are needed:
Does the left neighbour exist and is it smaller than the element to move?
The first check can be omitted through the use of \emph{sentinel values}:
If the element at index \(-1\) is at least as small as any value in the input array, the leftwards motion stops there at the latest.
Since a DPU has no branch predictor, the slowdown from performing twice as many checks as needed is quite high and lies at about 30\% for short inputs (\cref{fig:insertion:against_others}).

Setting an \emph{explicit} sentinel value can be omitted by using \emph{implicit} sentinel values.
At the start of each round, one can check if the element at index \(0\) is at least as small as the element at index~\(i\).
If yes, the former is a sufficient sentinel value, and \IS{} can proceed as normal.
If not, the latter must be the minimum of the first \(i + 1\) elements and, therefore, can be moved immediately to the front.

The runtimes of the explicit and implicit \IS*{} can be compared in the \cref{fig:insertion:against_others,fig:insertion:against_others_uint32,fig:insertion:against_others_uint64}.
For most input distributions, the implicit \IS{} is logically a bit slower, effectively adding one check instruction to each round.
An outlier, however, are the reverse sorted inputs.
For 32-bit numbers (\cref{fig:insertion:against_others_uint32}), the implicit version is up to 45\% slower than the explicit one.
This comes at a surprise since both versions effectively execute the same loop body while shifting everything one index backwards, with only the loop condition being different.
Due to the uni-cost model, a value check on whether the preceding element is smaller (explicit) and an address check on whether the preceding position is the start of the array (implicit) should take the same amount of time.
Yet, even the \IS{} not relying on sentinel values surpasses the implicit \IS{}, although doing both value checks and address checks!
For 64-bit numbers (\cref{fig:insertion:against_others_uint64}), the implicit \IS{} would be expected to perform better than the explicit one, considering that a value check now takes two instructions and an address check still only one.
Nonetheless, the two \IS*{} tie.

\begin{figure}
	\tikzsetnextfilename{insertion_against_others}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			horizontal sep for labels,
			adaptive group=1 by 2,
			groupplot xlabel={Input Length \(n\)},
			xtick distance=3,
			minor xtick=data,
			legend columns=3,
		]
			\nextgroupplot[ylabel=Cycles / \(n^2\), ymin=0, ymax=60, legend to name=leg:insertion:against_others]
			\legend{\IS{} (no sentinel), \IS{} (explicit), \IS{} (implicit), \BS{} (not adaptive), \BS{} (adaptive), \SelS{}}
			\plotpernn{1NoSentinel}{\tableSmallSortsXxxiiUniform}
			\plotpernn{1}{\tableSmallSortsXxxiiUniform}
			\plotpernn{1Implicit}{\tableSmallSortsXxxiiUniform}
			\plotpernn{BubbleNonAdapt}{\tableSmallSortsXxxiiUniform}
			\plotpernn{BubbleAdapt}{\tableSmallSortsXxxiiUniform}
			\plotpernn{Selection}{\tableSmallSortsXxxiiUniform}
			%
			\nextgroupplot[ylabel=Speed-up, ymin=0.2, ymax=1]
			\plotspeedup{1NoSentinel}{1}{\tableSmallSortsXxxiiUniform}
			\pgfplotsset{cycle list shift=1}
			\plotspeedup{1Implicit}{1}{\tableSmallSortsXxxiiUniform}
			\plotspeedup{BubbleNonAdapt}{1}{\tableSmallSortsXxxiiUniform}
			\plotspeedup{BubbleAdapt}{1}{\tableSmallSortsXxxiiUniform}
			\plotspeedup{Selection}{1}{\tableSmallSortsXxxiiUniform}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:insertion:against_others}\hfil
	\caption{
		Comparison of sorting algorithms with a runtime in \(\bigoh{n^2}\).
		The adaptive \BS{} terminates prematurely if no changes were made to the input array during an iteration.
		The speed-ups are with respect to the \IS{} relying on explicit sentinel values.
	}
	\label{fig:insertion:against_others}
\end{figure}

\input{singletasklet_insertion_compiler}

\begin{note}
	Other known simple sorting algorithm with a runtime complexity similar to \IS{} are \SelS{} and \BS{}.
	The asymptoticity, however, hides much higher constant factors such that \IS{} should always be preferred (cf.\ \cref{fig:insertion:against_others,fig:insertion:against_others_uint32,fig:insertion:against_others_uint64}).
\end{note}
