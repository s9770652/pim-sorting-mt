\subsection{\texorpdfstring{\MS{}}{MergeSort}}

\pgfplotstableread{data/wram_sorts.txt}{\tableWramSorts}
\def\mergealgos{16,24,32,48,64,96}
\expandafter\pgfplotsinvokeforeach\expandafter{\mergealgos}{
	\pgfplotstablereadnamed{data/merge/fallback=#1/uint32/sorted.txt}{tableMergeStart#1_32sorted}
	\pgfplotstablereadnamed{data/merge/fallback=#1/uint32/reverse.txt}{tableMergeStart#1_32reverse}
	\pgfplotstablereadnamed{data/merge/fallback=#1/uint32/almost.txt}{tableMergeStart#1_32almost}
	\pgfplotstablereadnamed{data/merge/fallback=#1/uint32/uniform.txt}{tableMergeStart#1_32uniform}
	\pgfplotstablereadnamed{data/merge/fallback=#1/uint32/zipf.txt}{tableMergeStart#1_32zipf}
	\pgfplotstablereadnamed{data/merge/fallback=#1/uint32/normal.txt}{tableMergeStart#1_32normal}
}

\MS{} repeatedly compares two sorted subarrays and merges them into a bigger sorted array in time \(\bigtheta{n \log n}\).
Unlike \QS{}, this runtime is guaranteed.
Furthermore, the sorting is naturally stable.

A simple but fast implementation of \MS{} writes all merged runs to an auxiliary array, raising the need for space for \(n\) additional elements (\enquote{Full space}).
The input array and the auxiliary array then switch roles, and the merging starts again.
Are the final sorted elements supposed to be saved in the original input array, a final round with a write-back from the auxiliary array to the input array is sometimes needed.

A slightly more sophisticated implementation needs space for only \(\sfrac{n}{2}\) additional elements (\enquote{Half space}):
When two adjacent runs are to be merged, the first one can be copied to an auxiliary array.
Then, the copy and the second run are merged to the start of the first run.
As a side effect, no write-back is ever needed and, additionally, the merging of two runs can be terminated prematurely once the last element of the copied run is merged, since the last elements of the other run are already in place.
%As a consequence, flushes will only be performed on at most half of the runs.

Instead of starting by merging runs of length 1, it is once again beneficial to fall back to simpler algorithms, namely \IS{} and \ShS{}.
Unlike \QS{}, where partitions naturally acted as sentinels for their neighbours, it is necessary to temporarily place sentinels values in front of each starting run and later restore the original values of the preceding run.
The optimal length for the starting runs depends on the length of the whole array, since it governs the number of rounds of merging, but lengths of 32 elements and 64 elements for the full space and half space \MS*{}, respectively, pose a good compromise, as suggested by \cref{fig:merge:starting_runs}.
In both cases, a \ShS{} with the step sizes \(\stepsizes = (4, 1)\) fares the best.
\todo{Warum? Widersprüchlich!}

\pgfplotsset{
	merge fallback/.style={
		horizontal sep for ticks,
		adaptive group=1 by 3,
		groupplot xlabel={Input Length \(n\)},
		groupplot ylabel={Cycles / \((n \lb n)\)},
		xmode=log,
		xtick={16, 64, 256, 1024},
		xticklabels={\(16\), \(64\), \(256\), \(1024\)},
		minor xtick={32, 128, 512},
		legend columns=-1,
	},
	merge sort filter 16/.style={x filter/.expression={(\thisrow{n} == 16) || (\thisrow{n} == 1024) || (\thisrow{n} ==  24) || (\thisrow{n} ==  96) || (\thisrow{n} == 384) ? \pgfmathresult : nan}},
	merge sort filter 24/.style={x filter/.expression={(\thisrow{n} == 16) || (\thisrow{n} == 1024) || (\thisrow{n} ==  32) || (\thisrow{n} == 128) || (\thisrow{n} == 512) ? \pgfmathresult : nan}},
	merge sort filter 32/.style={x filter/.expression={(\thisrow{n} == 16) || (\thisrow{n} == 1024) || (\thisrow{n} ==  48) || (\thisrow{n} == 192) || (\thisrow{n} == 768) ? \pgfmathresult : nan}},
	merge sort filter 48/.style={x filter/.expression={(\thisrow{n} == 16) || (\thisrow{n} == 1024) || (\thisrow{n} ==  64) || (\thisrow{n} == 256) ? \pgfmathresult : nan}},
	merge sort filter 64/.style={x filter/.expression={(\thisrow{n} == 16) || (\thisrow{n} == 1024) || (\thisrow{n} ==  96) || (\thisrow{n} == 384) ? \pgfmathresult : nan}},
	merge sort filter 96/.style={x filter/.expression={(\thisrow{n} == 16) || (\thisrow{n} == 1024) || (\thisrow{n} == 128) || (\thisrow{n} == 512) ? \pgfmathresult : nan}},
}

\begin{figure}
	\tikzsetnextfilename{merge_starting_runs}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[merge fallback]
			\nextgroupplot[title={No Write-back\strut}, legend to name=leg:merge:starting_runs]
			\expandafter\legend\expandafter{\mergealgos}
			\expandafter\pgfplotsinvokeforeach\expandafter{\mergealgos}{
				\plotpernlognnew[merge sort filter #1]{Merge}{tableMergeStart#1_32uniform}
			}
			%
			\nextgroupplot[title={Write-back\strut}]
			\expandafter\pgfplotsinvokeforeach\expandafter{\mergealgos}{
				\plotpernlognnew[merge sort filter #1]{MergeWriteBack}{tableMergeStart#1_32uniform}
			}
			%
			\nextgroupplot[title={Half Space}]
			\expandafter\pgfplotsinvokeforeach\expandafter{\mergealgos}{
				\plotpernlognnew[merge sort filter #1]{MergeHalfSpace}{tableMergeStart#1_32uniform}
			}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:merge:starting_runs}\hfil
	\caption{
		Comparison of \MS*{}, which need an auxiliary array of length either \(n\) (\enquote{No Write-back} / \enquote{Write-back}) or \(\sfrac{n}{2}\) (\enquote{Half Space}), for different lengths of the starting runs.
		The \MS*{} use a \ShS{} with the step sizes \(\stepsizes = (1)\) for length 16, \(\stepsizes = (6, 1)\) for lengths 24 to 48, and \(\stepsizes = (12, 5, 1)\) for lengths 64 and 96, respectively.
	}
	\label{fig:merge:starting_runs}
\end{figure}

\begin{note}
	Yet again, the compiler shows unforeseen behaviour.
%	Were one to check for short input array at the start in order to
	For example, when sorting the starting runs, a \ShS{} with step sizes \(\stepsizes = (4, 1)\) may be used.
	For the very first run,

	Compilation is worsened by:
	\begin{itemize}
		\item
		return, falls nur ein Start-Run

		\item
		Wächterwechsel beim ersten run

%		\item
%		Nur insertionSort ist etwas schlechter als nötig bei Half Space selbst bei n=16 für i32, aber besser für i64
%		Bzw.: komisch bei Eingaben, die aus nur einem Run bestehen. Ist aber für Merge Sort egal, da große Felder gewollt
	\end{itemize}
\end{note}

\subsubsection{Comparison with \texorpdfstring{\QS{}}{QuickSort}}




\begin{figure}
	\tikzsetnextfilename{wram_sorts}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			horizontal sep for labels,
			adaptive group=1 by 2,
			groupplot xlabel={Input Length \(n\)},
			xmode=log,
			xtick={20, 32, 64, 128, 256, 512, 1024},
			xticklabels={\(20\), \(32\), \(64\), \(128\), \(256\), \(512\), \(1024\)},
			legend columns=3,
		]
			\nextgroupplot[ylabel=Cycles / \((n \lb n)\), ymin=0, ymax=200, legend to name=leg:wram_sorts]
			\legend{\MS{} (no write-back), \QS{}, \ShS, \MS{} (write-back), \HS{}, \MS{} (half space)}
			\plotpernlogn{Merge}{\tableWramSorts}
			\plotpernlogn{Quick}{\tableWramSorts}
			\plotpernlogn{Shell}{\tableWramSorts}
			\plotpernlogn{MergeWriteBack}{\tableWramSorts}
			\plotpernlogn{Heap}{\tableWramSorts}
			\plotpernlogn{MergeHalfSpace}{\tableWramSorts}
			%
			\nextgroupplot[ylabel=Speed-up, ymin=0.3, ymax=1, extra y ticks={0.3}]
			\plotspeedup{Merge}{Quick}{\tableWramSorts}
			\pgfplotsset{cycle list shift=1}
			\plotspeedup{Shell}{Quick}{\tableWramSorts}
			\plotspeedup{MergeWriteBack}{Quick}{\tableWramSorts}
			\plotspeedup{Heap}{Quick}{\tableWramSorts}
			\plotspeedup{MergeHalfSpace}{Quick}{\tableWramSorts}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:wram_sorts}\hfil
	\caption{
		Comparison of \MS{}, \HS{}, \ShS{}, and \QS{}.
		Due to \MS{}'s increased space requirements, its runtime was measured only for up to 768 elements.
		The \ShS{} uses the step sizes from \cref{fig:shell:against_others}, which are unoptimised for large input sizes.
		The speed-ups are with respect to the \QS{}.
	}
	\label{fig:wram_sorts}
\end{figure}
