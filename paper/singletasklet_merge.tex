\subsection{\texorpdfstring{\MS{}}{MergeSort}}

\pgfplotstableread{data/wram_sorts.txt}{\tableWramSorts}

\begin{figure}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			width=0.4401\linewidth,
			group/group size=2 by 1,
			groupplot xlabel={Input Length \(n\)},
			xmode=log,
			xtick={20, 32, 64, 128, 256, 512, 1024},
			xticklabels={\(20\), \(32\), \(64\), \(128\), \(256\), \(512\), \(1024\)},
			legend columns=3,
		]
			\nextgroupplot[ylabel=Cycles / \((n \lb n)\), ymin=0, ymax=200, legend to name=leg:wram_sorts]
			\legend{\MS{} (no write-back), \QS{}, \ShS, \MS{} (write-back), \HS{}}
			\plotpernlogn{Merge}{\tableWramSorts}
			\plotpernlogn{Quick}{\tableWramSorts}
			\plotpernlogn{Shell}{\tableWramSorts}
			\plotpernlogn{MergeWriteBack}{\tableWramSorts}
			\plotpernlogn{Heap}{\tableWramSorts}
			%
			\nextgroupplot[ylabel=Speed-up, ymin=0.3, ymax=1, extra y ticks={0.3}]
			\plotspeedup{Merge}{Quick}{\tableWramSorts}
			\pgfplotsset{cycle list shift=1}
			\plotspeedup{Shell}{Quick}{\tableWramSorts}
			\plotspeedup{MergeWriteBack}{Quick}{\tableWramSorts}
			\plotspeedup{Heap}{Quick}{\tableWramSorts}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:wram_sorts}\hfil
	\caption{
		Comparison of \MS{}, \HS{}, \ShS{}, and \QS{}.
		Due to \MS{}'s increased space requirements, its runtime was measured only for up to 768 elements.
		The \ShS{} uses the step sizes from \cref{fig:quick_vs_insert_vs_shell}, which are unoptimised for large input sizes.
		The speed-ups are with respect to the \QS{}.
	}
	\label{fig:wram_sorts}
\end{figure}

\MS{} repeatedly compares two sorted subarrays and merges them into a bigger sorted array in time \(\bigtheta{n \log n}\).
Unlike \QS{}, this runtime is guaranteed.
Furthermore, the sorting is stable naturally.

The fastest implementation of \MS{} writes all merged runs to an output array, raising the need for additional space for \(n\) elements.
Since in this implementation, the arrays from which it is read and to which it is written switch each round, the final sorted array may not be saved where the input array was.
Thus, a final round with a write-back to the original position is sometimes needed.

A slightly more sophisticated implementation needs additional space for only \(\sfrac{n}{2}\) elements:
When two adjacent runs are to be merged, the first one can be copied to an auxiliary array.
Then, the copy and the second run are merged to the position of the first run.
As a side effect, no write-back is ever needed and, additionally, the merging of two runs can be terminated prematurely once the last element of the copied run is merged since the last elements of the other run are already in place, that is, flushes will only be performed on at most half of the runs.

Compilation is worsened by:
\begin{itemize}
	\item
	return, falls nur ein Start-Run

	\item
	kein WÃ¤chterwechsel beim ersten run
\end{itemize}
