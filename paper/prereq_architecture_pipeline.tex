\subsection{The Instruction Pipeline}
\label{sec:prereq:arch:pipeline}

Instructions are executed using \emph{pipelining}, that is, instructions are divided into several stages which are performed one after another, with each stage taking exactly one cycle.
Once a stage has been completed, the respective transistors are free to process the next instruction even if the previous instruction has not reached the end of the pipeline yet.
The pipeline is \emph{scalar}, meaning there is at most one instruction per stage at any time, and \emph{executes in order}, meaning instructions are statically scheduled and executed in the order as indicated by the compilation.
Threads can have only one scheduled instruction in the pipeline.
However, all threads use the same pipeline, so a nominal throughput of one instruction per cycle is achieved if enough threads are active for all stages of the pipeline to be continuously performed (\cref{fig:arch:pipeline}).
The pipeline consists of fourteen stages, amongst these the fetching of the instruction from the \ac{IRAM}, the reading of the operands from the registers, and the performing of the operation itself while accessing the \ac{WRAM} if needed.
The last three stages can be performed in parallel with the first three stages.
Thence, the pipeline length is effectively reduced to eleven, meaning only eleven active threads are needed to exploit the full computing capabilities of a DPU.

Nevertheless, having more than eleven threads active is not detrimental to the throughput, which remains at one instruction per cycle, it only means that individual threads are put into a queue and have to wait for some cycles.
This not only may make some parallel task easier to program, it can result in a performance gain when \acp{DMA} are involved.
\Acp{DMA} are mainly executed by the autonomous \ac{DMA} engine.
Whilst a thread is performing a \ac{DMA}, it is suspended and removed from the pipeline, freeing a slot up.
Therefrom, the employment of more than eleven threads allows to hide \ac{DMA} latency by keeping the pipeline full.

As concluding remark, it shall be mentioned that there are circumstances under which the execution of an instruction takes twelve cycles instead of eleven.
This is related to the identifiers of the registers used, however, the compiler usually manages to avoid these situations.
Hence, one can regard a \ac{DPU} as a \emph{uniform-cost machine} where each instruction takes eleven cycles to complete with the seldom exception of some taking twelve cycles and with the exception of \acp{DMA}.
Counting instructions is, therefore, a valid technique to assess the performance of some piece of code.

\begin{figure}
	\centering
%	\includegraphics[page=65]{example-image-duck}
	\begin{tikzpicture}[
		sketch,
		scale=0.95,
		stage/.style={ node distance=0mm, font=\addfontfeatures{RawFeature=+lnum}, inner sep=0 },
		flow/.style={ {Straight Barb[width=1.5mm]}-{Straight Barb[width=1.5mm]} },
		flow left/.style={ {Straight Barb[width=1.5mm]}- },
		flow right/.style={ -{Straight Barb[width=1.5mm]} },
	]
		\def\stagewidth{8.25}
		\draw[draw=none, fill=accentcolor!10] (0,  -0) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Thread Selection};                    % DISPATCH
		\draw[draw=none, fill=accentcolor!25] (0,  -1) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Instruction Fetch};                   % FETCH1
		\draw[draw=none, fill=accentcolor!25] (0,  -2) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Instruction Fetch};                   % FETCH2
		\draw[draw=none, fill=accentcolor!25] (0,  -3) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Instruction Fetch};                   % FETCH3
		\draw[draw=none, fill=accentcolor!10] (0,  -4) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Re\smash{g}ister Access};             % READOP1
		\draw[draw=none, fill=accentcolor!10] (0,  -5) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Re\smash{g}ister Access};             % READOP2
		\draw[draw=none, fill=accentcolor!10] (0,  -6) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Re\smash{g}ister Access};             % READOP3
		\draw[draw=none, fill=accentcolor!25] (0,  -7) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erand Formattin\smash{g}};  % FORMAT
		\draw[draw=none, fill=accentcolor!10] (0,  -8) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU1
		\draw[draw=none, fill=accentcolor!10] (0,  -9) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU2
		\draw[draw=none, fill=accentcolor!10] (0, -10) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU3
		\draw[draw=none, fill=accentcolor!10] (0, -11) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU4
		\draw[draw=none, fill=accentcolor!25] (0, -12) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Result Formattin\smash{g}};           % MERGE1
		\draw[draw=none, fill=accentcolor!25] (0, -13) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Result Formattin\smash{g}};           % MERGE2

		\draw[draw=none] (0,  -0) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}1};
		\draw[draw=none] (0,  -1) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}2};
		\draw[draw=none] (0,  -2) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}3};
		\draw[draw=none] (0,  -3) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}4};
		\draw[draw=none] (0,  -4) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}5};
		\draw[draw=none] (0,  -5) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}6};
		\draw[draw=none] (0,  -6) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}7};
		\draw[draw=none] (0,  -7) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}8};
		\draw[draw=none] (0,  -8) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}9};
		\draw[draw=none] (0,  -9) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}10};
		\draw[draw=none] (0, -10) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}11};
		\draw[draw=none] (0, -11) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}12};
		\draw[draw=none] (0, -12) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}13};
		\draw[draw=none] (0, -13) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}14};

		\draw (0, 0) rectangle +(\stagewidth, -14);
		\foreach \i in {13,...,1}{
			\draw (0, -\i) -- +(\stagewidth, 0);
		}

		% Memories.
		\def\pad{1}
		\def\lenmemx{3}
		\draw[fill=black!5] (-\pad-\lenmemx,    -7.5) rectangle +(\lenmemx, 3) node[stage, midway, align=center] {Register\\File};
		\draw[fill=black!5] (\stagewidth+\pad,  -4.5) rectangle +(\lenmemx, 3) node[stage, midway]               {IRAM};
		\draw[fill=black!5] (\stagewidth+\pad, -13.5) rectangle +(\lenmemx, 5) node[stage, midway]               {WRAM};

		% Arrows.
		\draw[flow right] (\stagewidth,  -2) -- +(\pad, 0);
		\draw[flow left]  (\stagewidth,  -4) -- +(\pad, 0);
		\draw[flow left]  (      -\pad,  -5) -- +(\pad, 0);
		\draw[flow right] (      -\pad,  -7) -- +(\pad, 0);
		\draw[flow right] (\stagewidth,  -9) -- +(\pad, 0);
		\draw[flow left]  (\stagewidth, -13) -- +(\pad, 0);
	\end{tikzpicture}

	\caption{
		The pipeline of a \ac{DPU}.~\cite{upmem2019HotChips}
	}
	\label{fig:arch:pipeline}
\end{figure}
