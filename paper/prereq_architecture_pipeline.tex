\subsection{The Instruction Pipeline}
\label{sec:prereq:arch:pipeline}

Instructions are executed using \emph{pipelining}, that is, instructions are divided into several steps which are performed one after another, with each step taking exactly one cycle.
Once a step has been completed, the respective transistors are free to process the next instruction even if the previous instruction has not reached the end of the pipeline yet.
All threads use the same pipeline such that a nominal throughput of one instruction per cycle is achieved if enough threads are active so that all steps of the pipeline are continuously performed.
\Cref{fig:arch:pipeline} shows the individual steps of the pipeline.
First, the instruction itself has to be loaded from the \ac{IRAM}.
Then, its argument are loaded from the registers before the actual computation is performed while accessing the \ac{WRAM} if necessary.
%to read \ac{MRAM} data, it has to be loaded first via a \ac{DMA} into the \ac{WRAM}, and to modify \ac{MRAM} data, \ac{WRAM} data has to be written first before writing it to the \ac{MRAM} via a \ac{DMA}.
Although the step count is 14, the last three steps can be performed in parallel with the first three steps.
This means that the pipeline length is effectively reduced to 11, meaning only eleven active threads are needed to fully exploit the computing capabilities of a DPU.

Nevertheless, having more than eleven threads active is not detrimental to the throughput, which remains at one instruction per cycle, it only means that individual threads are put into a queue and have to wait for some cycles.
This not only may make a parallel task easier to program, it can result in a performance gain when \acp{DMA} are involved.
\Acp{DMA} are mainly executed by the autonomous \ac{DMA} engine.
Whilst a thread is performing a \ac{DMA}, it is suspended and removed from the pipeline, freeing a slot up.
Therefrom, the employment of more than eleven threads allows to hide \ac{DMA} latency by keeping the pipeline full.

As concluding remark, it shall be mentioned that there are circumstances under which the execution of an instruction takes twelve cycles instead of eleven.
This is related to the identifiers of the used registers, however the compiler usually manages to avoid these situations.
Hence, one can regard a \ac{DPU} as a \emph{uniform-cost machine} where each instruction takes eleven cycles to complete with the seldom exception of some taking twelve cycles and with the exception of \acp{DMA}.
Counting instructions is, therefore, a valid technique to assess the performance of some piece of code.

\begin{figure}
	\centering
%	\includegraphics[page=65]{example-image-duck}
	\begin{tikzpicture}[
		sketch,
		scale=0.95,
		stage/.style={ node distance=0mm, font=\addfontfeatures{RawFeature=+lnum}, inner sep=0 },
		flow/.style={ {Straight Barb[width=1.5mm]}-{Straight Barb[width=1.5mm]} },
		flow left/.style={ {Straight Barb[width=1.5mm]}- },
		flow right/.style={ -{Straight Barb[width=1.5mm]} },
	]
		\def\stagewidth{8.25}
		\draw[draw=none, fill=accentcolor!10] (0,  -0) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Thread Selection};                    % DISPATCH
		\draw[draw=none, fill=accentcolor!25] (0,  -1) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Instruction Fetch};                   % FETCH1
		\draw[draw=none, fill=accentcolor!25] (0,  -2) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Instruction Fetch};                   % FETCH2
		\draw[draw=none, fill=accentcolor!25] (0,  -3) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Instruction Fetch};                   % FETCH3
		\draw[draw=none, fill=accentcolor!10] (0,  -4) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Re\smash{g}ister Access};             % READOP1
		\draw[draw=none, fill=accentcolor!10] (0,  -5) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Re\smash{g}ister Access};             % READOP2
		\draw[draw=none, fill=accentcolor!10] (0,  -6) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Re\smash{g}ister Access};             % READOP3
		\draw[draw=none, fill=accentcolor!25] (0,  -7) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erand Formattin\smash{g}};  % FORMAT
		\draw[draw=none, fill=accentcolor!10] (0,  -8) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU1
		\draw[draw=none, fill=accentcolor!10] (0,  -9) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU2
		\draw[draw=none, fill=accentcolor!10] (0, -10) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU3
		\draw[draw=none, fill=accentcolor!10] (0, -11) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {O\smash{p}erators};                   % ALU4
		\draw[draw=none, fill=accentcolor!25] (0, -12) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Result Formattin\smash{g}};           % MERGE1
		\draw[draw=none, fill=accentcolor!25] (0, -13) rectangle +(\stagewidth, -1) node[stage, midway, xshift=2mm] {Result Formattin\smash{g}};           % MERGE2

		\draw[draw=none] (0,  -0) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}1};
		\draw[draw=none] (0,  -1) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}2};
		\draw[draw=none] (0,  -2) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}3};
		\draw[draw=none] (0,  -3) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}4};
		\draw[draw=none] (0,  -4) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}5};
		\draw[draw=none] (0,  -5) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}6};
		\draw[draw=none] (0,  -6) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}7};
		\draw[draw=none] (0,  -7) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}8};
		\draw[draw=none] (0,  -8) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}9};
		\draw[draw=none] (0,  -9) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}10};
		\draw[draw=none] (0, -10) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}11};
		\draw[draw=none] (0, -11) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}12};
		\draw[draw=none] (0, -12) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}13};
		\draw[draw=none] (0, -13) rectangle +(1, -1) node[stage, midway] {\vphantom{lg}14};

		\draw (0, 0) rectangle +(\stagewidth, -14);
		\foreach \i in {13,...,1}{
			\draw (0, -\i) -- +(\stagewidth, 0);
		}

		% Memories.
		\def\pad{1}
		\def\lenmemx{3}
		\draw[fill=black!5] (-\pad-\lenmemx,    -7.5) rectangle +(\lenmemx, 3) node[stage, midway, align=center] {Register\\File};
		\draw[fill=black!5] (\stagewidth+\pad,  -4.5) rectangle +(\lenmemx, 3) node[stage, midway]               {IRAM};
		\draw[fill=black!5] (\stagewidth+\pad, -13.5) rectangle +(\lenmemx, 5) node[stage, midway]               {WRAM};

		% Arrows.
		\draw[flow right] (\stagewidth,  -2) -- +(\pad, 0);
		\draw[flow left]  (\stagewidth,  -4) -- +(\pad, 0);
		\draw[flow left]  (      -\pad,  -5) -- +(\pad, 0);
		\draw[flow right] (      -\pad,  -7) -- +(\pad, 0);
		\draw[flow right] (\stagewidth,  -9) -- +(\pad, 0);
		\draw[flow left]  (\stagewidth, -13) -- +(\pad, 0);
	\end{tikzpicture}

	\caption{
		The pipeline of a \ac{DPU}.
	}
	\label{fig:arch:pipeline}
\end{figure}
