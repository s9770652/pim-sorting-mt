\pgfplotstableread{data/small_sorts.txt}{\tablesmallsorts}

\begin{figure}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			width=0.4358\linewidth,
			group/group size=2 by 1,
			groupplot xlabel={Input Length \(n\)},
			xtick distance=3,
			minor xtick=data,
			legend columns=-1,
		]
			\nextgroupplot[ylabel=Cycles / \(n^2\), ymin=0, ymax=80, legend to name=leg:insertion_sort]
			\legend{Insertion, Insertion (no sentinel), Bubble, Bubble(adaptive), Selection}
			\plotpernn{1}{\tablesmallsorts}
			\plotpernn{1NoSentinel}{\tablesmallsorts}
			\plotpernn{BubbleNonAdapt}{\tablesmallsorts}
			\plotpernn{BubbleAdapt}{\tablesmallsorts}
			\plotpernn{Selection}{\tablesmallsorts}
			%
			\nextgroupplot[ylabel=Speed-up, ymin=0.2, ymax=1]
			\pgfplotsset{cycle list shift=1}
			\plotspeedup{1NoSentinel}{1}{\tablesmallsorts}
			\plotspeedup{BubbleNonAdapt}{1}{\tablesmallsorts}
			\plotspeedup{BubbleAdapt}{1}{\tablesmallsorts}
			\plotspeedup{Selection}{1}{\tablesmallsorts}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:insertion_sort}\hfil
	\caption{
		Comparison of sorting algorithms with \(\bigoh{n^2}\) runtime on a uniform input distribution.
		The \IS*{} differ in whether they rely on sentinel values.
		The adaptive \BS{} terminates prematurely if no changes were made to the input array during an iteration.
		The speed-ups are with respect to the \IS{} relying on sentinel values.
	}
	\label{fig:insertion_sort}
\end{figure}

\paragraph{\IS{}}
This stable sorting algorithm works by moving the \(i\)th element to the left as long as its left neighbour is bigger, assuming that the elements \(0\) to \(i - 1\) are already sorted.
Even though in both the average case and the worst case, \IS{} has a runtime of \(\bigoh{n^2}\)\todo{Beleg?}, it features quite some advantages:
\begin{enumerate*}
	\item
	It works in-place, needing only \(\bigoh{1}\) additional space.

	\item
	It is inherently adaptive:
	If the input array is mostly or even fully sorted, the runtime drops down to \(\bigoh{n}\).

	\item
	Its program code is short, lending itself to inlining.

	\item
	The overhead is small.
\end{enumerate*}
Especially the last two points make \IS{} a good base algorithm for asymptotically better sorting algorithms to use on very small subarrays.

When moving an element to the left, two checks are needed:
Does the left neighbour exist and is it smaller than the element to move?
The first check can be omitted through the use of \emph{sentinel values}:
If the element at index \(-1\) is at least as small as any value in the input array, the leftwards motion stops there at the latest.
Since a DPU has no branch predictor, the slowdown from performing twice as many checks as needed is quite high and lies between 20\% and 40\%\todo{auf Kompilat eingehen?} in the relevant input range (\cref{fig:insertion_sort}).%
\todo{ex- und implizite Wächterwerte benennen}
\todo[inline]{auf Compilersperenzchen eingehen?}

Other known simple sorting algorithm with similar runtime complexity are \SelS{} and \BS{}.
The asymptoticity, however, hides much higher constant factors such that even for as little as three elements \IS{} is superior (\cref{fig:insertion_sort}) and should always be used.



\begin{figure}
	\begin{tikzpicture}[plot]
		\begin{groupplot}[
			width=0.4358\linewidth,
			group/group size=2 by 1,
			groupplot xlabel={Input Length \(n\)},
			xtick distance=3,
			minor xtick=data,
			legend columns=-1,
		]
			\nextgroupplot[ylabel=Cycles / \(n^2\), ymin=0, ymax=80, legend to name=leg:shell_sort]
			\legend{\(1\), \(...\), \(9\)}
			\pgfplotsinvokeforeach{1,...,9}{
				\plotpernn{#1}{\tablesmallsorts}
			}
			%
			\nextgroupplot[ylabel=Speed-up, ymin=0.6, ymax=1.2]
			\pgfplotsset{cycle list shift=1}
			\pgfplotsinvokeforeach{2,...,9}{
				\plotspeedup{#1}{1}{\tablesmallsorts}
			}
		\end{groupplot}
	\end{tikzpicture}

	\hfil\pgfplotslegendfromname{leg:shell_sort}\hfil
	\caption{
		Comparison of \IS{} (1) and various \ShS*{} (2--9) on a uniform input distribution.
		Each \ShS{} does one \IS{} pass with a step size between 2 and 9 before doing a pass of regular \IS{}.
		The speed-ups are with respect to the \IS{}.
	}
	\label{fig:shell_sort}
\end{figure}

\paragraph{\ShS{}}
\IS{} suffers from small elements at the end of the input array, since those have to be brought to the front through \(\bigoh{n}\) comparisons and swaps.
\ShS{}, proposed by Donald L. Shell in 1959 \cite{Shell1959AHS}, remedies this by doing multiple passes of \IS{} with different step sizes:
In round \(i\) with step size \(h_i\), the input array is divided into the subarrays of indices \((0, h_i, 2 h_i, \dots)\), \((1, h_i + 1, 2 h_i +1, \dots)\), \((2, h_i + 2, 2 h_i + 2, \dots)\) and so on which then get sorted individually via \IS{}.
The step size decreases with each round, with the final step size being \(1\) such that a regular \IS{} is performed.
The individual \IS*{} should be fast since elements which need to travel long distances already did big jumps.

Finding the right balance between the heightened overhead through multiple \IS{} passes and the shortened runtime of each \IS{} pass is subject to research\todo{Belege} and depends on the cost of the operations (comparing, swapping, looping)\todo{Unikosten für DPU analysierend einbauen?}.
Let us first take a quick look on \ShS{} for small input arrays where surely only two rounds with step sizes \(h_1\) and \(1\) suffice.
The previous results on \IS{} suggest that \ShS{} should make use of \(h_1\) sentinel values.
\Cref{fig:shell_sort} shows that the additional rounds starts to pay off at 19 elements for \(h_1 \ge 5\), at 20 elements for \(h_1 \ge 3\), and at 25 elements for \(h_1 = 2\).
Bear in mind that these measurements were conducted on a uniform input distribution;
if \ShS{} is used by another algorithm on a subarray, these thresholds may be even higher or even non-existent due to some degree of presorting.
