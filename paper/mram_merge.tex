\section{Merging in MRAM}
\label{sec:mram:merge}

The MRAM \MS{} is based on the half-space WRAM \MS{} as presented in \cref{sec:tasklet:merge} so only the adaptations to the two-tier memory hierarchy are discussed.

The underlying idea during merging is the following:
First, initialise a sequential reader on either run.
Then, use the sequential readers to repeatedly compare two elements, one per run.
The less elements are written to the cache, that is the front part of the triple buffer.
If the cache is full, write its content to the output location.
Once the end of the run with the less tail element is reached, stop comparing and write the content of the cache to the output location.
Since the sorting algorithm is based on half-space \MS{}, the merging is now done if the run with the less tail element was the first run, as the remainder of the second run is already in the correct position.
If the run with the less tail element was the second run, flush the first one by transferring its remainder from the MRAM to the output location with the help of the entire triple buffer.

The overall merge process is two-tiered to avoid constantly checking whether the less run\todo{Bezeichnung schon in \cref{sec:tasklet} einf√ºhren!} is depleted\todo{ebenso}.
The function \lstinline|seqreader_tell| can be used to get the corresponding MRAM address of an element in a sequential-read buffer.
As long as there are at least \(\unrollfactor{} - 1\) elements between the current element of the less run and the tail element, the first tier is in operation.
An unrolled loop with \unrollfactor{} iterations is executed, with each iteration comparing the current elements of both runs, writing the less element to the cache, and advancing the pointer to the respective current element.
Afterwards, it is checked whether the cache is filled with \unrolledcachelength{} many elements, with \unrolledcachelength{} being a multiple of \unrollfactor{}.
If not, it is jumped back to the beginning of the tier, where the distance of the current element to the tail element is checked.
If, however, the cache is indeed too full, its content is written to the output location before it is jumped back to the beginning of the tier.

Once the first tier ends because the distance between the current element and the tail element of the less run is too small, there is a first check on whether the less run is depleted with ensuing flushing of the other run if positive.
If, however, the check is negative, the second tier begins.
It is structurally equal to the first tier with one exception, for there is no guarantee that the unrolled loop will be executed in full:
The check for the depletion now happens whenever an element of the less run is written to the cache.
When it occurs, the cache and the other run are flushed, and the merger stops.

\begin{algorithm}
	\KwIn{%

	}
	\KwOut{%

	}

	\While{there are least \unrollfactor{} many items left in Run 0}{
		\If{condition}{then block}
		\Else{else block}
	}

	\caption{
	}
	\label{alg}
\end{algorithm}
