\subsubsection*{Investigation of the Compilation}
\label{subsubsec:tasklet:quick:compilation}

\def\quickpivots{LAST,MEDIAN,RANDOM,MEDIAN_OF_RANDOM}
\expandafter\pgfplotsinvokeforeach\expandafter{\quickpivots}{
	\pgfplotstablereadnamed{data/quick/matrix/iterative/#1/shorter/uniform.txt}{tableQuickMatrixIt#1Shorter}
	\pgfplotstablereadnamed{data/quick/matrix/iterative/#1/left/uniform.txt}{tableQuickMatrixIt#1Left}
	\pgfplotstablereadnamed{data/quick/matrix/iterative/#1/right/uniform.txt}{tableQuickMatrixIt#1Right}

	\pgfplotstablereadnamed{data/quick/matrix/recursive/#1/shorter/uniform.txt}{tableQuickMatrixRec#1Shorter}
	\pgfplotstablereadnamed{data/quick/matrix/recursive/#1/left/uniform.txt}{tableQuickMatrixRec#1Left}
	\pgfplotstablereadnamed{data/quick/matrix/recursive/#1/right/uniform.txt}{tableQuickMatrixRec#1Right}
}

The quality of the compilation and thus the real performance of \QS{} is erratic to such an extent that one implementation variant may see a speed-up of 25\% over another one even with the same pivot choice although virtually none would be expected.
As hinted in the preceding paragraphs, this raises the need for a benchmark suite with the following parameters:
base case handling, recursion/iteration, pivot choice, and partition prioritisation.
Before the results are discussed, the first parameter shall be explained in more depth.

Besides falling back to \IS{} if 13 elements remain (\enquote{treshold undercut}), another base case is imaginable, namely a full termination if 1, 0, or --1 elements remain (\enquote{trivial length}).
Theoretically, it should not be needed to check for trivial lengths because even though it is doable with just one additional instruction, such short partitions are rare and the \IS{} would terminate after a few instructions anyway.
Nonetheless, its inclusion or exclusion can have significant impacts.
The following \nameCrefs{imp:normal} were tested:
\begin{enumerate}
	\item\label[implementation]{imp:normal}
	If the length is trivial, terminate.
	If not and if the threshold is undercut, sort with \IS{}.
	Otherwise, sort with \QS{} and use \QS{} on both partitions.
%	\textcolor{red}{[Normal]}

	\item\label[implementation]{imp:triviality_within_threshold}
	If the threshold is undercut, check if the length is trivial and terminate or sort with \IS{}, respectively.
	Otherwise, sort with \QS{} and use \QS{} on both partitions.
%	\textcolor{red}{[TrivInThresh]}
	\begin{itemize}
		\item
		This \nameCref{imp:triviality_within_threshold} significantly reduces the number of checks for trivial length.
	\end{itemize}

	\item\label[implementation]{imp:no_triviality}
	If the threshold is undercut, sort with \IS{}.
	Otherwise, sort with \QS{} and use \QS{} on both partitions.
%	\textcolor{red}{[NoTrivial]}
	\begin{itemize}
		\item
		This \nameCref{imp:no_triviality} forgoes the check for a trivial length completely, at the cost of unneeded \IS*{}.
	\end{itemize}

	\item\label[implementation]{imp:threshold_then_triviality}
	If the threshold is undercut, sort with \IS{}.
	If not and if the length is trivial, terminate.
	Otherwise, sort with \QS{} and use \QS{} on both partitions.
%	\textcolor{red}{[ThreshThenTriv]}
	\begin{itemize}
		\item
		This \nameCref{imp:threshold_then_triviality}, while nonsensical from a logical point of view, gives the compiler an explicit guarantee that the partitioning loop does not end immediately.
	\end{itemize}

	\item\label[implementation]{imp:triviality_before_call}
	If the threshold is undercut, sort with \IS{}.
	Otherwise, sort with \QS{}.
	Then check for either partition if its length is trivial and use \QS{} if not.
%	\textcolor{red}{[TrivialBC]}
	\begin{itemize}
		\item
		This \nameCref{imp:triviality_before_call}, as well as the next two, gets rid of some unneeded uses of \QS{}.
		In the recursive case, these \nameCrefs{imp:triviality_before_call} lose the property of being tail-recursive.
	\end{itemize}

	\item\label[implementation]{imp:threshold_before_call}
	Sort with \QS{}.
	Check for either partition if the threshold is undercut and use \IS{} or \QS{}, respectively.
%	\textcolor{red}{[ThreshBC]}

	\item\label[implementation]{imp:threshold_and_triviality_before_call}
	Sort with \QS{}.
	Check for either partition if its length is trivial or if the threshold is undercut and use \IS{}, \QS{}, or nothing, respectively.
%	\textcolor{red}{[ThreshTrivBC]}

	\item\label[implementation]{imp:one_insertion}
	If the threshold is undercut, terminate.
	Otherwise, sort with \QS{} and use \QS{} on both partitions.
	After all \QS*{} are done, sort the whole input array with \IS{}.
%	\textcolor{red}{[OneInsertion]}
	\begin{itemize}
		\item
		This \nameCref{imp:one_insertion} always does one pass of \IS{}.
		For example, the other \nameCrefs{imp:normal} do roughly 90 at 1024 elements.
	\end{itemize}
\end{enumerate}

All results are shown in \cref{fig:quick:implementations}.
When using recursion, \cref{imp:normal,imp:triviality_before_call} perform the best, especially for longer inputs.
Their compilations are fundamentally the same, including the conversion of the second recursive call into a jump back to the function start.
All other \nameCrefs{imp:normal} fare vastly worse.
Common occurrences are \dots{}
\begin{itemize}
	\item
	\dots{} one more instruction in the loop finding the next element to move to the right, \dots{}

	\item
	\dots{} one more instruction after such an element has been found, \dots{}

	\item
	\dots{} more stores and loads when entering and leaving the function.
\end{itemize}

\todo[inline]{%
	Ich kann mir leider nicht alles erklären.
	Als Beispiel habe ich die Kompilate von \cref{imp:normal} / Recursive / Last für Left First und Right First hochgeladen (die verkürzten Varianten besitzen nur noch Befehle und Sprungmarken).
	Ersteres ist ja die schnellste rekursive Variante, während letzteres deutlich schlechter abschneidet.
	Dennoch sehe ich bei der langsameren Variante keinen fundamental anderen Algorithmus.
	Je Funktionsaufruf kommen ≈3 Extra-Aufrufe hinzu (bei insgesamt ≈104 rekursiven und ≈104 \enquote{Endaufrufen} bei 1024 Elementen), was fast 70\,000 Takte Unterschied nicht erklären kann.
}

\clearpage

\begin{figure}[p]
	\pgfplotsset{
		height=2.574cm,
		horizontal sep for naught,
		vertical sep for naught,
		adaptive group=3 by 4,
		groupplot xlabel={Input Length \(n\)},
		groupplot ylabel={Cycles / \((n \lb n)\)},
		xmode=log,
		xtick={16, 64, 256, 1024},
		xticklabels={\(16\), \(64\), \(256\), \(1024\)},
		minor xtick={32, 128, 512},
		ymin=55,
		ymax=80,
		legend columns=-1,
	}
	\def\quickalgos{Normal,TrivInThresh,NoTrivial,ThreshThenTriv,TrivialBC,ThreshBC,ThreshTrivBC,OneInsertion}
	\captionsetup[subfigure]{aboveskip=0mm,belowskip=1mm}
	\begin{subfigure}{\textwidth}
		\tikzsetnextfilename{quick_implementations_rec}
		\begin{tikzpicture}[plot]
			\begin{groupplot}
				\nextgroupplot[title=Last, xticklabels={}, legend to name=leg:quick:implementations]
				\legend{\ref{imp:normal}, \ref{imp:triviality_within_threshold}, \ref{imp:no_triviality}, \ref{imp:threshold_then_triviality}, \ref{imp:triviality_before_call}, \ref{imp:threshold_before_call}, \ref{imp:threshold_and_triviality_before_call}, \ref{imp:one_insertion}}
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecLASTLeft}
				}
				\nextgroupplot[title=Median, xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecMEDIANLeft}
				}
				\nextgroupplot[title=Random, xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecRANDOMLeft}
				}
				\nextgroupplot[title=Median (Random), xticklabels={}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecMEDIAN_OF_RANDOMLeft}
				}
				%
				\nextgroupplot[xticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecLASTRight}
				}
				\nextgroupplot[xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecMEDIANRight}
				}
				\nextgroupplot[xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecRANDOMRight}
				}
				\nextgroupplot[xticklabels={}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecMEDIAN_OF_RANDOMRight}
				}
				%
				\nextgroupplot
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecLASTShorter}
				}
				\nextgroupplot[yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecMEDIANShorter}
				}
				\nextgroupplot[yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecRANDOMShorter}
				}
				\nextgroupplot[yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixRecMEDIAN_OF_RANDOMShorter}
				}
			\end{groupplot}
		\end{tikzpicture}
		\caption{
			Recursive Approach
		}
	\end{subfigure}
	\begin{subfigure}{\textwidth}
		\tikzsetnextfilename{quick_implementations_it}
		\begin{tikzpicture}[plot]
			\begin{groupplot}
				\nextgroupplot[title=Last, xticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItLASTLeft}
				}
				\nextgroupplot[title=Median, xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItMEDIANLeft}
				}
				\nextgroupplot[title=Random, xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItRANDOMLeft}
				}
				\nextgroupplot[title=Median (Random), xticklabels={}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItMEDIAN_OF_RANDOMLeft}
				}
				%
				\nextgroupplot[xticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItLASTRight}
				}
				\nextgroupplot[xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItMEDIANRight}
				}
				\nextgroupplot[xticklabels={}, yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItRANDOMRight}
				}
				\nextgroupplot[xticklabels={}, yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItMEDIAN_OF_RANDOMRight}
				}
				%
				\nextgroupplot
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItLASTShorter}
				}
				\nextgroupplot[yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItMEDIANShorter}
				}
				\nextgroupplot[yticklabels={}]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItRANDOMShorter}
				}
				\nextgroupplot[yticklabel pos=right]
				\expandafter\pgfplotsinvokeforeach\expandafter{\quickalgos}{
					\plotpernlogn{#1}{tableQuickMatrixItMEDIAN_OF_RANDOMShorter}
				}
			\end{groupplot}
		\end{tikzpicture}
		\caption{
			Iterative Approach
		}
	\end{subfigure}

	\tikzexternaldisable
	\hfil\pgfplotslegendfromname{leg:quick:implementations}\hfil
	\tikzexternalenable
	\caption{
		Comparison of \crefrange{imp:normal}{imp:one_insertion} and different pivots.
		Left-hand partitions are prioritised in the first rows, right-hand ones in the second rows, and shorter ones in the third rows.
	}
	\label{fig:quick:implementations}
\end{figure}

\clearpage
