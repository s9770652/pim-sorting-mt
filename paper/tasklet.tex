\chapter{Sorting Sequentially in WRAM}
\label{sec:tasklet}

This \lcnamecref{sec:tasklet} is concerned with the very first phase where each tasklet sorts on its own, that is sequentially, solely in WRAM.
\Cref{sec:tasklet:insertion} discusses \IS{} which is a component of all algorithms presented thereafter as it is lightweight and performant on short inputs.
\Cref{sec:tasklet:shell} covers \ShS{} which is a generalisation of \IS{}.
\hyperref[sec:tasklet:heap]{\nameCrefs{sec:tasklet:heap} }\labelcref{sec:tasklet:heap}, \labelcref{sec:tasklet:quick}, and \labelcref{sec:tasklet:merge} deal with \HS{}, \QS{}, and \MS{}, respectively, which are more elaborate algorithms suitable for long inputs.
These \lcnamecrefs{sec:tasklet:insertion} give a short presentation of their respective algorithm at the beginning, ensued by a discussion of key parameters in their designs.
There follows usually an insight into non-algorithmic challenges faced during development caused by the compiler.
Finally, an evaluation of the performance of the respective algorithm completes each \lcnamecref{sec:tasklet:insertion}.
\Cref{sec:tasklet:conclusion} summarises the findings on the presented algorithms and gives a brief outlook on future improvements.

\Cref{apx:tasklet} contains a comprehensive collection of measurements but the ones essential for following the content of this \lcnamecref{sec:tasklet} are also presented in figures herein.
Every measurement was repeated a thousand times with the sorting algorithms in their default configuration unless explicitly noted otherwise.
The meaning behind and reasoning for the individual parameters in the configurations are subject in \crefrange{sec:tasklet:insertion}{sec:tasklet:merge} but shall be already mentioned for ease of reference:
\begin{description}
	\item[\IS{}]
	explicit sentinel value

	\item[\ShS{}]
	explicit sentinel values;
	step sizes \(\stepsizes = (1, 6)\) for inputs with at most 64 elements and \(\stepsizes = (1, 4, 17)\) for longer ones

	\item[\HS{}]
	top-down for 32-bit integers;
	bottom-up with swap disparity for 64-bit integers

	\item[\QS{}]
	fallback threshold of 18 elements;
	random medians as pivots;
	prioritisation of right-hand partitions over left-hand partitions;
	iterative for 32-bit integers;
	recursive for 64-bit integers;
	\Cref*{imp:triviality_before_call}

	\item[\MS{}]
	half-space;
	starting run length of 16 elements
\end{description}

The measurements were confined to at most 1024 elements.
The reason is that 64 kibibytes of WRAM are available and that the DPU pipeline throughput is saturated at 11 tasklets when ignoring secondary effects through MRAM accesses and synchronisation.
This alots 5957 bytes, that is space for about 1489 32-bit integers, to each tasklet.
That number is further reduced by a few hundred of those bytes serving as stack for their respective tasklet.
On that score, 1024 elements is a reasonable cutoff.

\clearpage
\input{tasklet_insertion}

\clearpage
\input{tasklet_shell}

\clearpage
\input{tasklet_heap}

\clearpage
\input{tasklet_quick}

\clearpage
\input{tasklet_merge}

\clearpage
\input{tasklet_conclusion}
